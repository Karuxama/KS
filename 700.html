<html>
<head>
 <title>Компьютерные системы - 9. Ассоциативные вычисления и КС</title>
 <META http-equiv=Content-Type content="text/html; charset=Windows-1251">
 <META name=GENERATOR   content="SunRav BookEditor" >
 <META name=keywords    content="">
 <META name=description content="9. Ассоциативные вычисления и КС">
 <link rel="stylesheet" href="styles.css" type="text/css">
</head>
<body style="background: url(back_62.jpg)">
<!-- Generated by SunRav BookOffice -->
 <table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tr>
   <td valign="top">
    
<p><img border=0 width=572 height=130 alt="" hspace=1 vspace=1 src="img/img_0.jpg"><span class=rvts20> </span></p>

    
<p><span class=rvts31>Ассоциативные вычисления и КС</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Главное отличие ассоциативной ВС от обычной системы последовательной обработки информации состоит в </span><span class=rvts18>использовании ассоциативной памяти</span><span class=rvts6> или подобного устройства, а не памяти с адресуемыми ячейками.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts18>Ассоциативная память (АП)</span><span class=rvts6> допускает обращение за данными на основе их признака или ключевого слова: имени, набора характеристик, задания диапазона и т.д.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts18>Распространенный вид АП</span><span class=rvts6> — таблица с двумя столбцами: " запросное поле — ответное поле. Строка таблицы занимает регистр памяти. По ключевому слову обрабатываются запросные поля: производится поиск на основе сравнений и выдается результат из одного (или более) ответных полей. При помощи маскирования можно выделить только те поля в ключевом слове, которые нужно использовать при поиске для сравнения.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts18>(Пролон системы! Базы данных!)</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Типичными операциями сравнения, выполняемыми ассоциативной памятью, являются: "равно — не равно", "ближайшее меньше чем — ближайшее больше чем", "не больше чем — не меньше чем", "максимальная величина — минимальная величина", "между границами — вне границ", "следующая величина больше — следующая величина меньше" и др. Т.е. все это есть </span><span class=rvts18>операции отношения</span><span class=rvts6> и определения принадлежности.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Поскольку ассоциативные ВС характеризуются только активным использованием АП в вычислениях, то в целом эти ВС обладают обычными свойствами, могут производить сложные преобразования данных и </span><span class=rvts18>принадлежать типу ОКМД</span><span class=rvts6> (STARAN, PEPE) или </span><span class=rvts18>МКМД</span><span class=rvts6>. Для параллельного обращения (для ускорения поиска) АП разбита на модули (32 модуля — в STARAN).</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Когда в 1980 г. был провозглашен так называемый "Японский вызов" о построении ВС сверхвысокой производительности, то одним из пунктов была указана необходимость самого широкого использования принципов самообучающихся систем — систем, способных накапливать опыт и выдавать результат решения задачи без счета самой задачи. Это значит, что </span><span class=rvts18>применение ассоциативных ВС неотделимо от проблемы искусственного интеллекта.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Предположим, мы пользуемся значениями функции 000000 - 001111. Мы можем запрограммировать счет этой функции на РС, и каждый раз, когда нам надо, задаем x и запускаем программу, пользуясь прекрасным современным сервисом.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Предположим, та же функция сложна, а ее счет — важный элемент алгоритма управления в реальном времени. Решение приходит сразу: зададим эту функцию таблично, а для ускорения выборки включим в ВС ассоциативную память. Предусмотрим на ней операции, позволяющие производить простейшую интерполяцию. А именно, для данного значения x найти наибольший x1 &lt; x и наименьший x2 &gt;= x. Для них выбрать f(x1) и f(x2). Тогда вместо счета точного значения f(x) процессору остается произвести хотя бы линейную интерполяцию</span></p>
<p><span class=rvts6> </span></p>
<p><span class=rvts6>f(x) =&nbsp; f(x1) + (f(x1) - f(x2)) * (х - х1) / (x2 - x1),</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>надо только быть уверенным в достижении нужной точности.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Однако в повседневной жизни мы очень часто решаем </span><span class=rvts39>трудноформализуемые задачи</span><span class=rvts6>, когда алгоритм решения не очевиден. Но мы учимся, обретаем опыт, затем оцениваем складывающуюся ситуацию на "похожесть" и принимаем решение.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Простейшая задача: как мы автоматически определяем, на сколько надо </span><span class=rvts18>повернуть рулевое колесо</span><span class=rvts6>, чтобы остаться на дороге? Ведь первый раз мы въезжали в бордюр! Значит, некая таблица постепенно сложилась и зафиксировалась в нашем сознании.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Пожалуй, наиболее полно автоматически и с наибольшей практичностью решение задачи самообучения представлено в артиллерии, точнее — </span><span class=rvts18>в правилах стрельбы</span><span class=rvts6>.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>После занятия огневой позиции подготовка установок для ведения огня занимает много времени. На рассчитанных установках по каждой цели производится пристрелка, когда цель захватывается в широкую вилку, затем по наблюдениям вилка "половинится" до тех пор, пока на середине узкой вилки не переходят на поражение. После стрельбы следует замечательная команда "Стой, записать...", по которой наводчик на щите орудия пишет номер цели и все пристрелянные установки по ней. Такая работа проделывается и </span><span class=rvts18>по фиктивным целям — реперам.</span><span class=rvts6> Постепенно при "работе" на данной местности запоминаются пристрелянные установки по многим целям и реперам. С их появлением и развитием подготовка данных по вновь появляющимся целям резко упрощается, т.к. сводится к переносу огня от ближайшей цели или репера, т.е. к внесению поправок по дальности и направлению. Доказано, что при этом достаточно сразу назначать захват цели в узкую вилку, т.е. пристрелка упрощается. </span><span class=rvts39>Правила стрельбы существуют века</span><span class=rvts6>, однако вряд ли кто-то осознавал теоретически, что речь идет о реализации </span><span class=rvts39>самообучающейся системы.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Для трудноформализуемых задач управления или для увеличения производительности вычислительных средств известно так называемое </span><span class=rvts18>ситуационное управление</span><span class=rvts6>. Оно заключается в том, что для каждого значения вектора, описывающего сложившуюся ситуацию, известно значение вектора, описывающего то решение, которое следует принять. Если все ситуации отразить невозможно, должно быть задано правило интерполяции (аналог интерполяции, обобщенной интерполяции).</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Итак, пусть исходная ситуация характеризуется вектором X = {x1, ..., xm}. По значению X, т.е. по его компонентам, принимается решение Y, также представляющее собой вектор, Y = {y1, ..., yn}.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>(Значения X и Y могут определяться целыми и вещественными, булевыми. Изначально они могут иметь нечисловую природу: "темнее — светлее", "правее — левее", "ласковее — суровее" и т.д. Мы не будем рассматривать проблему численной оценки качественных или эмоциональных категорий.)</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Предположим, для любых двух значений X1 и X2, а также Y1 и Y2 определено отношение xi(1) &lt;= xi(2) (или наоборот), yj(1) &lt;= yj(2) (или наоборот).</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Структура ассоциативной памяти и общий вид ее обработки показаны на рисунке.</span></p>
<p><span class=rvts6><br></span></p>
<p><img border=0 width=1230 height=757 alt="" hspace=1 vspace=1 src="img/img_107.jpg"></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Пусть поступила входная ситуация X, для которой необходимо найти решение Y. В АП находятся два вектора X1 и X2, минимально отличающиеся по всем координатам от вектора X. для Для этих векторов там же записаны векторы решения Y1 и Y2 соответственно. Однако если для компоненты xi выполняется условие xi &lt;= xi(1)(xi &gt;= xi(1)), то должно выполняться условие xi &gt;= xi(2)(xi &lt;= xi(2)), i = 1, ..., m. Таким образом, </span><span class=rvts18>отыскивается "вилка", которой принадлежит входная ситуация.</span><span class=rvts6> Тогда, опираясь на известные решения на границах этой вилки, необходимо выдать промежуточное решение для данной ситуации. Это можно сделать методом той же обобщенной интерполяции</span></p>
<p><span class=rvts6><br></span></p>
<p><img border=0 width=1188 height=401 alt="" hspace=1 vspace=1 src="img/img_108.jpg"></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>r(X,X2) и r(X1,X2) (находится аналогично) — расстояния между векторами X и X2, а также X1 и X2.</span></p>
<p><span class=rvts6>Если известно, что точность Y достаточна, принципиально возможно дополнение АП новой строкой X - Y, т.е. информацией о новом полученном опыте.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Однако динамика развития и уточнения АП как базы знаний представляется иной. Далеко не всегда по ошибочному принятию решений целесообразно развивать базу знаний. "Учение на ошибках" может привести к трагедии (или к частному срыву процесса управления), особенно на этапе обучения системы.</span></p>
<p><span class=rvts6><br></span></p>
<p><span class=rvts6>Обучение системы целесообразно проводить на достаточно точной модели, максимально использующей точный расчет компонент решения. Применение модели для обучения используется не только на специально предусмотренном этапе обучения системы, но и вне реального цикла управления, т.е. когда система работает в режиме дежурства, параллельно с функциональным контролем. Тогда алгоритм ее работы представлен на рисунке.</span></p>
<p><img border=0 alt="" hspace=1 vspace=1 src="img/img_109.jpg"></p>
<p><img border=0 alt="" hspace=1 vspace=1 src="img/img_110.jpg"></p>
<p><span class=rvts6>Алгоритм работы самообучающейся системы управления.</span></p>
<p><a href="730.html"><img border=0 alt="" hspace=1 vspace=1 src="img/img_111.jpg"></a></p>
<p><span class=rvts6><br></span></p>

    
<p><span class=rvts30>---------------------------------------</span></p>
<p><span class=rvts30>© 2021 Косолапов А.А.</span></p>

   </td>
  </tr>
 </table>
</body>
</html>
