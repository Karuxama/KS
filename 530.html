<html>
<head>
 <title>Компьютерные системы - Схема коммутации омега</title>
 <META http-equiv=Content-Type content="text/html; charset=Windows-1251">
 <META name=GENERATOR   content="SunRav BookEditor" >
 <META name=keywords    content="">
 <META name=description content="Схема коммутации омега">
 <link rel="stylesheet" href="styles.css" type="text/css">
</head>
<body style="background: url(back_46.jpg)">
<!-- Generated by SunRav BookOffice -->
 <table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tr>
   <td valign="top">
    
<p><img border=0 width=572 height=130 alt="" hspace=1 vspace=1 src="img/img_0.jpg"><span class=rvts20> </span></p>

    
<p><span class=rvts31>Схема коммутации Омега</span></p>
<p><span class=rvts31><br></span></p>
<p><img border=0 width=1068 height=455 alt="" hspace=1 vspace=1 src="img/img_70.jpg"></p>
<p><span class=rvts31><br></span></p>
<p class=rvps3><span class=rvts6>Здесь с помощью </span><span class=rvts18>12</span><span class=rvts6> коммутаторов </span><span class=rvts18>восемь</span><span class=rvts6> центральных процессоров подключаются к </span><span class=rvts18>восьми</span><span class=rvts6> модулям памяти. </span></p>
<p class=rvps3><span class=rvts6><br></span></p>
<p class=rvps3><span class=rvts18>Схему электрической разводки в сети Омега часто называют идеальным тасованием (perfect shuffle), </span><span class=rvts6>поскольку перемешивание сигналов на каждой ступени походит на колоду карт, поделенную на две части, а затем перемешиваемую путем заведения одних карт за другие. </span></p>
<p class=rvps3><span class=rvts6><br></span></p>
<p class=rvps3><span class=rvts31>Работа сети</span></p>
<p class=rvps3><span class=rvts6><br></span></p>
<p class=rvps3><span class=rvts6>Чтобы разобраться с работой сети </span><span class=rvts18>Омега</span><span class=rvts6>, предположим, что ЦПУ </span><span class=rvts18>011</span><span class=rvts6> понадобилось прочитать слово из модуля памяти </span><span class=rvts18>110</span><span class=rvts6>. ЦПУ посылает сообщение READ коммутатору </span><span class=rvts18>1D</span><span class=rvts6>, в котором в поле </span><span class=rvts18>Модуль</span><span class=rvts6> содержится значение </span><span class=rvts18>110</span><span class=rvts6>. Коммутатор берет первый (то есть самый левый) бит из </span><span class=rvts18>110</span><span class=rvts6> и использует его для маршрутизации. </span></p>
<p class=rvps3><span class=rvts6><br></span></p>
<p class=rvps3><span class=rvts6>Если значение равно </span><span class=rvts18>0</span><span class=rvts6>, сообщение направляется </span><span class=rvts18>на верхний выход</span><span class=rvts6>, а если </span><span class=rvts18>1</span><span class=rvts6> - ,&nbsp; направляется </span><span class=rvts18>на нижний выход</span><span class=rvts6>. Поскольку бит содержит </span><span class=rvts18>1</span><span class=rvts6>, сообщение направляется через нижний выход на коммутатор </span><span class=rvts18>2D</span><span class=rvts6>. </span></p>
<p class=rvps3><span class=rvts6><br></span></p>
<p class=rvps3><span class=rvts6>Все </span><span class=rvts39>коммутаторы второй ступени</span><span class=rvts6>, включая 2D, </span><span class=rvts39>используют для маршрутизации </span><span class=rvts18>второй</span><span class=rvts39> бит</span><span class=rvts6>. В данном случае он также равен 1, поэтому теперь сообщение направляется через нижний выход к коммутатору 3D. Там уже тестируется третий бит, который равен 0. Следовательно, сообщение направляется через верхний выход и попадает, как и требовалось, к модулю памяти 110. </span><span class=rvts39>Путь, по которому проходит это сообщение, помечен на рисунке буквой a.</span></p>
<p class=rvps3><span class=rvts6><br></span></p>
<p class=rvps3><span class=rvts6>По мере прохождения сообщения по схеме коммутации самые левые биты номера модуля утрачивают свое значение. Ими можно воспользоваться снова, записывая в них номер входящей линии, чтобы ответ смог отыскать обратный путь. Для пути a входные линии имеют номера </span><span class=rvts18>0</span><span class=rvts6> (верхний вход </span><span class=rvts18>1D</span><span class=rvts6>), </span><span class=rvts18>1</span><span class=rvts6> (нижний вход </span><span class=rvts18>2D</span><span class=rvts6>) и </span><span class=rvts18>1</span><span class=rvts6> (нижний вход </span><span class=rvts18>3D</span><span class=rvts6>). Ответ будет направлен назад с помощью значения </span><span class=rvts18>011</span><span class=rvts6>, только на этот раз чтение из него будет производиться справа налево. </span></p>
<p class=rvps3><span class=rvts6><br></span></p>
<p class=rvps3><span class=rvts6>Предположим, что&nbsp; в это же время ЦПУ </span><span class=rvts18>001</span><span class=rvts6> требуется записать слово в модуль памяти </span><span class=rvts18>001</span><span class=rvts6>. Здесь происходит аналогичный процесс: сообщение направляется </span><span class=rvts18>по верхнему, по верхнему и по нижнему выходам</span><span class=rvts6>, этот путь помечен буквой </span><span class=rvts18>b</span><span class=rvts6>. Когда сообщение дойдет до адресата, его поле </span><span class=rvts18>Модуль</span><span class=rvts6> будет содержать значение </span><span class=rvts18>001</span><span class=rvts6>, представляющее пройденный им путь. Поскольку рассмотренные запросы не используют одни и те же коммутаторы, линии и модули памяти, они могут выполняться параллельно. </span></p>
<p class=rvps3><span class=rvts6><br></span></p>
<p class=rvps3><span class=rvts18>Конфликт:</span><span class=rvts6> если ЦПУ </span><span class=rvts18>000</span><span class=rvts6> одновременно с этим захочет обратиться к модулю памяти </span><span class=rvts18>000</span><span class=rvts6>. Его запрос вступит </span><span class=rvts18>в конфликт</span><span class=rvts6> с запросом ЦПУ </span><span class=rvts18>001</span><span class=rvts6> на коммутаторе </span><span class=rvts18>3A</span><span class=rvts6>. Одному из них придется подождать. </span></p>
<p class=rvps3><span class=rvts6><br></span></p>
<p class=rvps3><span class=rvts18>В отличие от координатного коммутатора, сеть Омега представляет собой блокирующуюся сеть (blocking network).</span><span class=rvts6> Не все наборы запросов могут обрабатываться одновременно. При использовании линий или коммутаторов могут возникать </span><span class=rvts18>конфликты как между запросами к памяти, так и между ответами от памяти.</span></p>
<p class=rvps3><span class=rvts6><br></span></p>
<p class=rvps3><span class=rvts34>Возникает потребность в равномерном распределении обращений к модулям памяти</span><span class=rvts6>. Одна из </span><span class=rvts18>распространенных технологий предусматривает использование младших разрядов в качестве номера модуля</span><span class=rvts6>. </span></p>
<p class=rvps3><span class=rvts6><br></span></p>
<p class=rvps3><span class=rvts6>Рассмотрим, к примеру, </span><span class=rvts18>байт-ориентированное адресное пространство компьютера</span><span class=rvts6>, который в основном обращается к целым 32-разрядным словам. </span></p>
<p class=rvps3><span class=rvts6><br></span></p>
<p class=rvps3><span class=rvts6>Два младших разряда обычно имеют значение </span><span class=rvts18>00</span><span class=rvts6>, но</span><span class=rvts18> следующие три бита будут распределены равномерно.&nbsp; </span><span class=rvts6>За счет использования этих трех битов в качестве номера модуля </span><span class=rvts18>последовательные слова будут находиться в последовательных модулях.</span><span class=rvts6> </span></p>
<p class=rvps3><span class=rvts6><br></span></p>
<p class=rvps3><span class=rvts39>Система памяти, в которой следующие друг за другом слова находятся в разных модулях, называется чередующейся (interleaved).</span><span class=rvts6> Чередующиеся системы памяти позволяют добиться максимального распараллеливания, потому что большинство обращений к памяти осуществляется к следующим друг за другом адресам. </span></p>
<p class=rvps3><span class=rvts6><br></span></p>
<p class=rvps3><span class=rvts6>Для более эффективного распространения потока данных можно также разработать неблокирующиеся схемы коммутации, предлагающие несколько путей от каждого ЦПУ к каждому модулю памяти.</span></p>
<p class=rvps3><span class=rvts6><br></span></p>
<p class=rvps3><span class=rvts6>В общем, для </span><span class=rvts18>N</span><span class=rvts6> ЦПУ и </span><span class=rvts18>N</span><span class=rvts6> модулей памяти понадобится </span><span class=rvts18>log2 N</span><span class=rvts6> ступеней с </span><span class=rvts18>N/2</span><span class=rvts6> коммутаторами на каждую ступень, а всего </span><span class=rvts18>(N/2) log2 N</span><span class=rvts6> коммутаторов, что значительно лучше, чем </span><span class=rvts18>NхN</span><span class=rvts6> элементов коммутации, особенно для больших </span><span class=rvts18>N</span><span class=rvts6>.</span></p>
<p><a href="250.html"><img border=0 alt="" hspace=1 vspace=1 src="img/img_71.jpg"></a></p>

    
<p><span class=rvts30>---------------------------------------</span></p>
<p><span class=rvts30>© 2021 Косолапов А.А.</span></p>

   </td>
  </tr>
 </table>
</body>
</html>
